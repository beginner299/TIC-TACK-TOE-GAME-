<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tic-Tac-Toe AI Game</title>
    <!-- Tailwind CSS CDN for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter font for a clean look -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Removed Tone.js for sound effects -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
            /* Enhanced Gradient Background */
            background: linear-gradient(135deg, #84fab0 0%, #8fd3f4 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
        }

        .game-container {
            background-color: rgba(255, 255, 255, 0.98); /* Slightly more opaque white for contrast */
            padding: 2.5rem;
            border-radius: 1.5rem; /* More rounded corners */
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.25); /* Stronger shadow */
            text-align: center;
            max-width: 90%;
            width: 450px; /* Fixed width for larger screens */
            transition: all 0.3s ease-in-out;
            border: 2px solid rgba(255, 255, 255, 0.5); /* Subtle border */
        }

        @media (max-width: 600px) {
            .game-container {
                width: 95%; /* Adjust width for smaller screens */
                padding: 1.5rem;
            }
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            color: #333;
            margin-bottom: 1.5rem;
            letter-spacing: -0.05em; /* Slightly tighter letter spacing */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }

        .game-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-gap: 0.75rem; /* Spacing between cells */
            width: 100%;
            max-width: 350px; /* Max width for the board */
            margin: 1.5rem auto;
            background-color: #e0e0e0; /* Light grey background for the grid area */
            border-radius: 0.75rem;
            padding: 0.75rem;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1); /* Inner shadow for depth */
        }

        .cell {
            width: 100%;
            height: 100px; /* Fixed height for cells */
            background-color: #f0f0f0; /* Lighter cell background */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 4rem;
            font-weight: 600;
            cursor: pointer;
            border-radius: 0.75rem; /* Rounded corners for cells */
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-out;
            position: relative; /* For SVG positioning */
            overflow: hidden; /* Ensure SVG doesn't overflow */
        }

        .cell:hover:not(.occupied) {
            background-color: #e5e5e5; /* Hover effect */
            transform: scale(1.02); /* Slight scale on hover */
        }

        .cell.occupied {
            cursor: not-allowed;
        }

        .cell.x svg {
            fill: #ef4444; /* Red for X */
            transform: scale(0.8); /* Slightly smaller to fit */
        }

        .cell.o svg {
            fill: #3b82f6; /* Blue for O */
            transform: scale(0.8);
        }

        .x-svg, .o-svg {
            position: absolute;
            width: 80%;
            height: 80%;
            opacity: 0;
            animation: fadeIn 0.3s ease-out forwards;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.5); }
            to { opacity: 1; transform: scale(1); }
        }

        .game-message {
            margin-top: 1.5rem;
            font-size: 1.5rem;
            font-weight: 600;
            color: #4a4a4a;
            min-height: 2rem; /* Reserve space */
        }

        .level-display {
            font-size: 1.2rem;
            font-weight: 600;
            color: #6a6a6a;
            margin-bottom: 1rem;
        }

        .reset-button {
            background: linear-gradient(90deg, #4ade80 0%, #22c55e 100%); /* Green gradient */
            color: white;
            padding: 0.8rem 2rem;
            border-radius: 9999px; /* Pill shape */
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            border: none;
            box-shadow: 0 8px 15px rgba(0, 128, 0, 0.2); /* Green shadow */
            transition: all 0.3s ease;
            outline: none;
        }

        .reset-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 20px rgba(0, 128, 0, 0.3);
        }

        .reset-button:active {
            transform: translateY(0);
            box-shadow: 0 5px 10px rgba(0, 128, 0, 0.2);
        }

        /* Win line animation */
        .win-line {
            position: absolute;
            background-color: #ffeb3b; /* Yellow win line */
            z-index: 10;
            animation: drawLine 0.5s ease-out forwards;
        }

        /* Horizontal lines */
        .win-line.row-0 { top: calc(100px / 2 + 0.75rem); left: 0.75rem; width: calc(100% - 1.5rem); height: 8px; }
        .win-line.row-1 { top: calc(100px * 1.5 + 0.75rem * 2); left: 0.75rem; width: calc(100% - 1.5rem); height: 8px; }
        .win-line.row-2 { top: calc(100px * 2.5 + 0.75rem * 3); left: 0.75rem; width: calc(100% - 1.5rem); height: 8px; }

        /* Vertical lines */
        .win-line.col-0 { left: calc(100px / 2 + 0.75rem); top: 0.75rem; height: calc(100% - 1.5rem); width: 8px; }
        .win-line.col-1 { left: calc(100px * 1.5 + 0.75rem * 2); top: 0.75rem; height: calc(100% - 1.5rem); width: 8px; }
        .win-line.col-2 { left: calc(100px * 2.5 + 0.75rem * 3); top: 0.75rem; height: calc(100% - 1.5rem); width: 8px; }

        /* Diagonal lines */
        .win-line.diag-0 { /* Top-left to bottom-right */
            top: 50%; left: 50%;
            width: calc(141.42% - 1.5rem); /* sqrt(2) * 100% */
            height: 8px;
            transform: translate(-50%, -50%) rotate(45deg);
            transform-origin: center;
        }
        .win-line.diag-1 { /* Top-right to bottom-left */
            top: 50%; left: 50%;
            width: calc(141.42% - 1.5rem);
            height: 8px;
            transform: translate(-50%, -50%) rotate(-45deg);
            transform-origin: center;
        }

        @keyframes drawLine {
            from {
                transform: scaleX(0);
                opacity: 0;
            }
            to {
                transform: scaleX(1);
                opacity: 1;
            }
        }

        /* Adjustments for diagonal line animation origin */
        .win-line.diag-0, .win-line.diag-1 {
            animation: drawDiagonalLine 0.5s ease-out forwards;
        }

        @keyframes drawDiagonalLine {
            from {
                width: 0;
                opacity: 0;
            }
            to {
                width: calc(141.42% - 1.5rem);
                opacity: 1;
            }
        }

        /* SVG for X and O */
        .x-icon {
            width: 100%;
            height: 100%;
            fill: none;
            stroke: currentColor; /* Use parent's fill color */
            stroke-width: 10;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .o-icon {
            width: 100%;
            height: 100%;
            fill: none;
            stroke: currentColor;
            stroke-width: 10;
        }
    </style>
</head>
<body class="selection:bg-purple-300 selection:text-purple-900">
    <div class="game-container">
        <h1 class="text-gray-800">Tic-Tac-Toe AI</h1>
        <div id="levelDisplay" class="level-display">Level: 1 (Wins: 0)</div>
        <div id="gameMessage" class="game-message">Player X's Turn</div>
        <div class="game-board" id="gameBoard">
            <!-- Cells will be dynamically generated here -->
        </div>
        <button id="resetButton" class="reset-button">Reset Game</button>
    </div>

    <script>
        // Removed Tone.js initialization for sound effects
        // Removed playSound function

        // Game state variables
        let board = ['', '', '', '', '', '', '', '', ''];
        let currentPlayer = 'X'; // X is always the player
        let computerPlayer = 'O'; // O is always the computer
        let gameActive = true;
        let playerWins = 0;
        let currentLevel = 1;

        // DOM elements
        const gameBoard = document.getElementById('gameBoard');
        const gameMessage = document.getElementById('gameMessage');
        const resetButton = document.getElementById('resetButton');
        const levelDisplay = document.getElementById('levelDisplay');

        // Winning combinations
        const winConditions = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
            [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns
            [0, 4, 8], [2, 4, 6]             // Diagonals
        ];

        // Function to draw X SVG
        function createXSVG() {
            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.setAttribute("viewBox", "0 0 100 100");
            svg.classList.add('x-svg');
            const line1 = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line1.setAttribute("x1", "20"); line1.setAttribute("y1", "20");
            line1.setAttribute("x2", "80"); line1.setAttribute("y2", "80");
            line1.classList.add('x-icon');
            const line2 = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line2.setAttribute("x1", "80"); line2.setAttribute("y1", "20");
            line2.setAttribute("x2", "20"); line2.setAttribute("y2", "80");
            line2.classList.add('x-icon');
            svg.appendChild(line1);
            svg.appendChild(line2);
            return svg;
        }

        // Function to draw O SVG
        function createOSVG() {
            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.setAttribute("viewBox", "0 0 100 100");
            svg.classList.add('o-svg');
            const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            circle.setAttribute("cx", "50"); circle.setAttribute("cy", "50");
            circle.setAttribute("r", "30");
            circle.classList.add('o-icon');
            svg.appendChild(circle);
            return svg;
        }

        // Initialize the game board cells
        function initializeBoard() {
            gameBoard.innerHTML = ''; // Clear existing cells
            board.forEach((cell, index) => {
                const cellElement = document.createElement('div');
                cellElement.classList.add('cell', 'rounded-xl'); // Tailwind rounded-xl for consistency
                cellElement.dataset.index = index;
                cellElement.addEventListener('click', handleCellClick);
                gameBoard.appendChild(cellElement);
            });
            updateLevelDisplay();
        }

        // Update the game message and level display
        function updateMessage(msg) {
            gameMessage.textContent = msg;
        }

        function updateLevelDisplay() {
            levelDisplay.textContent = `Level: ${currentLevel} (Wins: ${playerWins})`;
        }

        // Check for win or draw
        function checkWin() {
            let roundWon = false;
            let winningCondition = null;

            for (let i = 0; i < winConditions.length; i++) {
                const condition = winConditions[i];
                let a = board[condition[0]];
                let b = board[condition[1]];
                let c = board[condition[2]];

                if (a === '' || b === '' || c === '') {
                    continue;
                }
                if (a === b && b === c) {
                    roundWon = true;
                    winningCondition = condition;
                    break;
                }
            }

            if (roundWon) {
                gameActive = false;
                drawWinningLine(winningCondition); // Draw the line
                if (currentPlayer === 'X') {
                    updateMessage('You Win!');
                    playerWins++;
                    currentLevel = Math.min(playerWins + 1, 50); // Cap levels at 50
                } else {
                    updateMessage('Computer Wins!');
                    playerWins = Math.max(0, playerWins - 1); // Decrease wins on computer win
                    currentLevel = Math.max(1, currentLevel - 1); // Decrease level on computer win
                }
                updateLevelDisplay();
                return true;
            }

            // Check for draw
            if (!board.includes('')) {
                gameActive = false;
                updateMessage('It\'s a Draw!');
                return true;
            }
            return false;
        }

        // Draw the winning line
        function drawWinningLine(condition) {
            const boardRect = gameBoard.getBoundingClientRect();
            const cellElements = Array.from(gameBoard.children);
            const firstCell = cellElements[condition[0]];
            const lastCell = cellElements[condition[2]];

            const startRect = firstCell.getBoundingClientRect();
            const endRect = lastCell.getBoundingClientRect();

            const line = document.createElement('div');
            line.classList.add('win-line');

            // Determine line type (row, col, diag)
            if (condition[0] + 1 === condition[1] && condition[1] + 1 === condition[2]) { // Horizontal
                line.classList.add(`row-${condition[0] / 3}`);
            } else if (condition[0] + 3 === condition[1] && condition[1] + 3 === condition[2]) { // Vertical
                line.classList.add(`col-${condition[0] % 3}`);
            } else if (condition[0] === 0 && condition[1] === 4 && condition[2] === 8) { // Diagonal \
                line.classList.add('diag-0');
            } else if (condition[0] === 2 && condition[1] === 4 && condition[2] === 6) { // Diagonal /
                line.classList.add('diag-1');
            }

            gameBoard.appendChild(line);
        }

        // Handle player's move
        function handleCellClick(e) {
            const clickedCell = e.target;
            const clickedCellIndex = parseInt(clickedCell.dataset.index);

            if (board[clickedCellIndex] !== '' || !gameActive || currentPlayer !== 'X') {
                return;
            }

            makeMove(clickedCell, clickedCellIndex, currentPlayer);
            if (!checkWin()) {
                currentPlayer = computerPlayer;
                updateMessage('Computer\'s Turn');
                setTimeout(computerMove, 700); // Delay computer move for better UX
            }
        }

        // Make a move on the board
        function makeMove(cellElement, index, player) {
            board[index] = player;
            cellElement.classList.add('occupied', player.toLowerCase());
            if (player === 'X') {
                cellElement.appendChild(createXSVG());
            } else {
                cellElement.appendChild(createOSVG());
            }
            // Removed playSound('move');
        }

        // Computer AI logic based on level
        function computerMove() {
            if (!gameActive) return;

            let move = -1;

            if (currentLevel >= 16) { // Optimal AI (Minimax for Tic-Tac-Toe)
                move = findBestMove(board, computerPlayer);
            } else if (currentLevel >= 6) { // Medium AI: Win, Block, Center, Corner, Random
                move = findWinningMove(computerPlayer);
                if (move === -1) move = findWinningMove(currentPlayer); // Block player
                if (move === -1) move = findStrategicMove(); // Center or corners
                if (move === -1) move = findRandomMove();
            } else { // Easy AI: Random or simple block/win
                move = findWinningMove(computerPlayer); // Try to win
                if (move === -1) move = findWinningMove(currentPlayer); // Try to block
                if (move === -1) move = findRandomMove();
            }

            const cellElement = gameBoard.children[move];
            makeMove(cellElement, move, computerPlayer);

            if (!checkWin()) {
                currentPlayer = 'X';
                updateMessage('Player X\'s Turn');
            }
        }

        // AI Helper: Find a winning move for a given player
        function findWinningMove(player) {
            for (let i = 0; i < winConditions.length; i++) {
                const [a, b, c] = winConditions[i];
                const cells = [board[a], board[b], board[c]];
                const emptyIndex = cells.indexOf('');

                if (emptyIndex !== -1) { // If there's an empty spot in this condition
                    const potentialMoveIndex = winConditions[i][emptyIndex];
                    let tempBoard = [...board];
                    tempBoard[potentialMoveIndex] = player;
                    if (checkTempWin(tempBoard, player)) {
                        return potentialMoveIndex;
                    }
                }
            }
            return -1;
        }

        // AI Helper: Check win on a temporary board (for minimax or lookahead)
        function checkTempWin(tempBoard, player) {
            for (let i = 0; i < winConditions.length; i++) {
                const [a, b, c] = winConditions[i];
                if (tempBoard[a] === tempBoard[b] && tempBoard[b] === tempBoard[c] && tempBoard[a] !== '') {
                    return true;
                }
            }
            return false;
        }

        // AI Helper: Find strategic moves (center, corners)
        function findStrategicMove() {
            // Prefer center
            if (board[4] === '') return 4;
            // Prefer corners
            const corners = [0, 2, 6, 8];
            for (let i = 0; i < corners.length; i++) {
                if (board[corners[i]] === '') return corners[i];
            }
            return -1; // No strategic move found
        }

        // AI Helper: Find a random empty move
        function findRandomMove() {
            const emptyCells = [];
            for (let i = 0; i < board.length; i++) {
                if (board[i] === '') {
                    emptyCells.push(i);
                }
            }
            if (emptyCells.length > 0) {
                const randomIndex = Math.floor(Math.random() * emptyCells.length);
                return emptyCells[randomIndex];
            }
            return -1; // Should not happen in a non-full board
        }

        // Minimax algorithm for optimal AI
        function findBestMove(currentBoard, player) {
            let bestScore = (player === computerPlayer) ? -Infinity : Infinity;
            let move = -1;

            for (let i = 0; i < currentBoard.length; i++) {
                if (currentBoard[i] === '') {
                    currentBoard[i] = player;
                    let score = minimax(currentBoard, 0, false);
                    currentBoard[i] = ''; // Undo the move

                    if (player === computerPlayer) {
                        if (score > bestScore) {
                            bestScore = score;
                            move = i;
                        }
                    } else { // This part is not strictly needed for `findBestMove` but for the `minimax` function
                        if (score < bestScore) {
                            bestScore = score;
                            move = i;
                        }
                    }
                }
            }
            return move;
        }

        function minimax(currentBoard, depth, isMaximizingPlayer) {
            const scores = {
                'X': -1, // Player X wins (bad for computer)
                'O': 1,  // Computer O wins (good for computer)
                'draw': 0
            };

            let result = evaluateBoard(currentBoard);
            if (result !== null) {
                return scores[result];
            }

            if (isMaximizingPlayer) { // Computer's turn (O)
                let bestScore = -Infinity;
                for (let i = 0; i < currentBoard.length; i++) {
                    if (currentBoard[i] === '') {
                        currentBoard[i] = computerPlayer;
                        let score = minimax(currentBoard, depth + 1, false);
                        currentBoard[i] = '';
                        bestScore = Math.max(score, bestScore);
                    }
                }
                return bestScore;
            } else { // Player's turn (X)
                let bestScore = Infinity;
                for (let i = 0; i < currentBoard.length; i++) {
                    if (currentBoard[i] === '') {
                        currentBoard[i] = currentPlayer;
                        let score = minimax(currentBoard, depth + 1, true);
                        currentBoard[i] = '';
                        bestScore = Math.min(score, bestScore);
                    }
                }
                return bestScore;
            }
        }

        // Helper for minimax: evaluate current board state
        function evaluateBoard(currentBoard) {
            for (let i = 0; i < winConditions.length; i++) {
                const [a, b, c] = winConditions[i];
                if (currentBoard[a] === currentBoard[b] && currentBoard[b] === currentBoard[c] && currentBoard[a] !== '') {
                    return currentBoard[a]; // Returns 'X' or 'O'
                }
            }
            if (!currentBoard.includes('')) {
                return 'draw';
            }
            return null; // Game still ongoing
        }

        // Reset the game
        function resetGame() {
            board = ['', '', '', '', '', '', '', '', ''];
            currentPlayer = 'X';
            gameActive = true;
            initializeBoard(); // Re-render cells
            updateMessage('Player X\'s Turn');
        }

        // Event listeners
        resetButton.addEventListener('click', resetGame);

        // Initial setup
        window.onload = initializeBoard;
    </script>
</body>
</html>